{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../internals/Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants';\nimport { attachParent } from './attachParent';\n// gap of tree node\nvar TREE_NODE_GAP = 4;\n\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n *\n * @deprecated This {@link UNSAFE_flattenTree} function is considered unsafe because it mutates `tree` argument in-place\n *             Use {@link flattenTree} instead.\n */\nexport function UNSAFE_flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n  var flattenData = [];\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      flattenData.push(attachParent(node, parent));\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n  traverse(tree, null);\n  return flattenData;\n}\nexport var WalkTreeStrategy;\n(function (WalkTreeStrategy) {\n  WalkTreeStrategy[WalkTreeStrategy[\"DFS\"] = 0] = \"DFS\";\n  WalkTreeStrategy[WalkTreeStrategy[\"BFS\"] = 1] = \"BFS\";\n})(WalkTreeStrategy || (WalkTreeStrategy = {}));\nexport function flattenTree(rootNodes, getChildren, walkStrategy) {\n  if (walkStrategy === void 0) {\n    walkStrategy = WalkTreeStrategy.BFS;\n  }\n  var result = [];\n  if (walkStrategy === WalkTreeStrategy.BFS) {\n    walkTreeBfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  } else if (walkStrategy === WalkTreeStrategy.DFS) {\n    walkTreeDfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  }\n  return result;\n}\nexport function walkTreeBfs(rootNodes, getChildren, callback) {\n  for (var queue = [].concat(rootNodes); queue.length > 0;) {\n    var _node = queue.shift();\n    callback(_node);\n    var children = getChildren(_node);\n    if (children) {\n      queue.push.apply(queue, children);\n    }\n  }\n}\nexport function walkTreeDfs(rootNodes, getChildren, callback) {\n  for (var _iterator = _createForOfIteratorHelperLoose(rootNodes), _step; !(_step = _iterator()).done;) {\n    var _node2 = _step.value;\n    callback(_node2);\n    var children = getChildren(_node2);\n    if (children) {\n      walkTreeDfs(children, getChildren, callback);\n    }\n  }\n}\n\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n  var parents = [];\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n  traverse(node);\n  return parents;\n}\n\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n  var traverse = function traverse(node) {\n    var _node$parent;\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n\n/**\n * shallow equal array\n * @param a\n * @param b\n */\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n    defaultExpandAll = props.defaultExpandAll,\n    childrenKey = props.childrenKey,\n    _props$defaultExpandI = props.defaultExpandItemValues,\n    defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n  if (defaultExpandAll) {\n    return UNSAFE_flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n  return defaultExpandItemValues;\n}\n\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n    defaultExpandItemValues = props.defaultExpandItemValues;\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n  return [];\n}\n\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n    top = _treeNodeElement$getB.top,\n    bottom = _treeNodeElement$getB.bottom;\n  var gap = TREE_NODE_GAP;\n\n  // bottom of node\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  }\n\n  // top of node\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n    childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1);\n        // when children is empty, delete children prop for hidden anchor\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n        break;\n      }\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n    childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n      dropNode = params.dropNode,\n      dropNodePosition = params.dropNodePosition;\n    var cloneDragNode = _extends({}, dragNode);\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n            _item2[childrenKey].push(cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n      if (_isArray(_item3.children)) {\n        var _node3 = findNode(_item3.children);\n        if (_node3) {\n          return _node3;\n        }\n      }\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n    return undefined;\n  };\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n    var nextNodes = [];\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n    return nextNodes;\n  };\n  return findNodes(data);\n}\n\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n    valueKey = props.valueKey,\n    childrenKey = props.childrenKey,\n    expandItemValues = props.expandItemValues;\n  var items = [];\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n      if (!disabled && node.visible) {\n        items.push(node);\n      }\n      // always expand when searching\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n  loop(filteredData);\n  return items;\n};\n\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n  return null;\n};\n\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n/**\n * focus next item with keyboard\n * @param param\n */\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n    focusableItems = _ref3.focusableItems,\n    treeNodesRefs = _ref3.treeNodesRefs,\n    selector = _ref3.selector,\n    valueKey = _ref3.valueKey,\n    callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n  if (focusableItems.length === 0) {\n    return;\n  }\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n\n/**\n * focus prev item with keyboard\n * @param param\n */\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n    focusableItems = _ref4.focusableItems,\n    treeNodesRefs = _ref4.treeNodesRefs,\n    selector = _ref4.selector,\n    valueKey = _ref4.valueKey,\n    callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n  if (focusableItems.length === 0) {\n    return;\n  }\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n    expand = _ref5.expand,\n    onExpand = _ref5.onExpand,\n    onFocusItem = _ref5.onFocusItem;\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n    expand = _ref6.expand,\n    childrenKey = _ref6.childrenKey,\n    onExpand = _ref6.onExpand,\n    onFocusItem = _ref6.onFocusItem;\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\nexport { getTreeActiveNode };\n\n/**\n * toggle tree node\n * @param param0\n */\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n    isExpand = _ref7.isExpand,\n    expandItemValues = _ref7.expandItemValues,\n    valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n    return _nodes.join('');\n  }\n}\n\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n  var _useState = useState(null),\n    dragOverNodeKey = _useState[0],\n    setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n  var _useState2 = useState([]),\n    dragNodeKeys = _useState2[0],\n    setDragNodeKeys = _useState2[1];\n  var _useState3 = useState(null),\n    dropNodePosition = _useState3[0],\n    setDropNodePosition = _useState3[1];\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n/**\n * hooks for flatten tree structure\n * @param param0\n */\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n    labelKey = _ref8.labelKey,\n    valueKey = _ref8.valueKey,\n    childrenKey = _ref8.childrenKey,\n    _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n    uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n    callback = _ref8.callback;\n  var _useState4 = useState(Object.create(null)),\n    dispatch = _useState4[1];\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n    treeData.map(function (node) {\n      var _extends2;\n      var value = node[valueKey];\n      /**\n       * because the value of the node's type is string or number,\n       * so it can used as the key of the object directly\n       * to avoid number value is converted to string. 1 and '1' will be convert to '1'\n       *  we used `String_` or `Number_` prefix\n       */\n      var refKey = getNodeFormattedRefKey(value);\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n      flattenTreeData(node[childrenKey], node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n      key = _ref9.key,\n      _ref9$value = _ref9.value,\n      value = _ref9$value === void 0 ? [] : _ref9$value,\n      cascade = _ref9.cascade,\n      uncheckableItemValues = _ref9.uncheckableItemValues;\n    // Reset values to false\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n      searchKeyword = options.searchKeyword;\n    return UNSAFE_flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n      return formatted;\n    });\n  };\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data);\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n\n/**\n * A hook that saving every tree node ref\n */\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n/**\n * A hook that handles tree search filter options\n * @param props\n */\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n    childrenKey = props.childrenKey,\n    searchKeyword = props.searchKeyword,\n    data = props.data,\n    searchBy = props.searchBy,\n    callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]);\n\n  // Use search keywords to filter options.\n  var _useState5 = useState(searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : ''),\n    searchKeywordState = _useState5[0],\n    setSearchKeyword = _useState5[1];\n  var _useState6 = useState(function () {\n      return filterVisibleData(data, searchKeywordState);\n    }),\n    filteredData = _useState6[0],\n    setFilteredData = _useState6[1];\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    event && (callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event));\n  };\n  useEffect(function () {\n    handleSearch(searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchKeyword]);\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n    loadingNodeValues = _useState7[0],\n    setLoadingNodeValues = _useState7[1];\n  var _useState8 = useState(treeData),\n    data = _useState8[0],\n    setData = _useState8[1];\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n/**\n * Focus to active tree node.\n * @param param0\n */\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n  var list = _ref10.list,\n    valueKey = _ref10.valueKey,\n    activeNode = _ref10.activeNode,\n    virtualized = _ref10.virtualized,\n    container = _ref10.container,\n    selector = _ref10.selector,\n    formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n  var activeItem = container.querySelector(selector);\n  if (!activeItem) {\n    return;\n  }\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n  if (absolute === void 0) {\n    absolute = false;\n  }\n  // layer start from 1\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n  if (absolute) {\n    var _ref11;\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}\n\n/**\n * according to the value type to get the formatted valueKey of the node\n * @param value\n * @returns\n */\nexport function getNodeFormattedRefKey(value) {\n  return \"\" + (typeof value === 'number' ? 'Number_' : 'String_') + value;\n}\n\n/**\n * create drag preview when tree node start drag\n * @param name\n * @param className\n * @returns\n */\nexport function createDragPreview(name, className) {\n  var dragPreview = document.createElement('div');\n  dragPreview.id = 'rs-tree-drag-preview';\n  dragPreview.innerHTML = name;\n  dragPreview.classList.add(className);\n  document.body.appendChild(dragPreview);\n  return dragPreview;\n}\n\n/**\n * remove drag preview when tree node drop\n */\nexport function removeDragPreview() {\n  var _dragPreview$parentNo, _dragPreview$parentNo2;\n  var dragPreview = document.getElementById('rs-tree-drag-preview');\n  dragPreview === null || dragPreview === void 0 ? void 0 : (_dragPreview$parentNo = dragPreview.parentNode) === null || _dragPreview$parentNo === void 0 ? void 0 : (_dragPreview$parentNo2 = _dragPreview$parentNo.removeChild) === null || _dragPreview$parentNo2 === void 0 ? void 0 : _dragPreview$parentNo2.call(_dragPreview$parentNo, dragPreview);\n}\nexport function stringifyTreeNodeLabel(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes2 = reactToString(label);\n    return _nodes2.join('');\n  }\n  return '';\n}\n\n/**\n * Returns a WeakMap that maps each item in `items` to its parent\n * indicated by `getChildren` function\n */\nexport function getParentMap(items, getChildren) {\n  var map = new WeakMap();\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item5 = queue.shift();\n    var children = getChildren(_item5);\n    if (children) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {\n        var child = _step2.value;\n        map.set(child, _item5);\n        queue.push(child);\n      }\n    }\n  }\n  return map;\n}\n\n/**\n * Returns a Map that maps each item's \"key\", indicated by `getKey` function,\n * to its parent indicated by `getChildren` function\n *\n * NOTICE:\n * Using this function is discouraged.\n * Use {@link getParentMap} whenever possible.\n */\nexport function getKeyParentMap(items, getKey, getChildren) {\n  var map = new Map();\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item6 = queue.shift();\n    var children = getChildren(_item6);\n    if (children) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(children), _step3; !(_step3 = _iterator3()).done;) {\n        var child = _step3.value;\n        map.set(getKey(child), _item6);\n        queue.push(child);\n      }\n    }\n  }\n  return map;\n}\n\n/**\n * Returns an array indicating the hierarchy path from root towards `target` item\n */\nexport function getPathTowardsItem(target, getParent) {\n  if (!target) return [];\n  var path = [target];\n  for (var parent = getParent(target); !!parent; parent = getParent(parent)) {\n    path.unshift(parent);\n  }\n  return path;\n}","map":{"version":3,"names":["_extends","_isEmpty","_clone","_isNil","_isArray","_omit","_isUndefined","_intersection","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","minLen","_arrayLikeToArray","n","Object","prototype","toString","slice","constructor","name","from","test","arr","len","arr2","React","useRef","useState","useEffect","useCallback","shallowEqualArray","getNodeCheckState","TREE_NODE_DROP_POSITION","shallowEqual","shouldDisplay","reactToString","TREE_NODE_PADDING","TREE_NODE_ROOT_PADDING","attachParent","TREE_NODE_GAP","shouldShowNodeByParentExpanded","expandItemValues","parentKeys","intersectionKeys","UNSAFE_flattenTree","tree","childrenKey","executor","flattenData","traverse","data","parent","forEach","item","index","node","push","WalkTreeStrategy","flattenTree","rootNodes","getChildren","walkStrategy","BFS","result","walkTreeBfs","DFS","walkTreeDfs","callback","queue","concat","_node","shift","children","apply","_iterator","_step","_node2","getNodeParents","parentKey","valueKey","parents","getNodeParentKeys","nodes","_node$parent","refKey","_node$parent2","hasVisibleChildren","some","child","visible","compareArray","a","b","getDefaultExpandItemValues","props","defaultExpandAll","_props$defaultExpandI","defaultExpandItemValues","filter","map","getExpandItemValues","getDragNodeKeys","dragNode","dragNodeKeys","calDropNodePosition","event","treeNodeElement","clientY","_treeNodeElement$getB","getBoundingClientRect","top","bottom","gap","DRAG_OVER_BOTTOM","DRAG_OVER_TOP","DRAG_OVER","removeDragNode","params","_ref","items","_index","_item","splice","createUpdateTreeDataFunction","_ref2","dropNode","dropNodePosition","cloneDragNode","updateTree","_index2","_item2","findNodeOfTree","check","findNode","_item3","_node3","undefined","filterNodesOfTree","findNodes","nextNodes","nextChildren","_item4","getFocusableItems","filteredData","isSearching","disabledItemValues","loop","disabled","disabledItem","expand","includes","getActiveIndex","focusItemValue","focusItems","activeIndex","getActiveItem","flattenNodes","nodeData","activeNode","values","find","getElementByDataKey","dataKey","treeNodesRefs","selector","ele","Element","querySelector","focusTreeNode","treeNodeRefs","_node$focus","focus","focusNextItem","_ref3","focusableItems","nextIndex","nextFocusItemValue","focusPreviousItem","_ref4","prevIndex","prevFocusItemValue","leftArrowHandler","_ref5","focusItem","onExpand","onFocusItem","rightArrowHandler","_ref6","getScrollToIndex","findIndex","getExpandWhenSearching","searchKeyword","getTreeActiveNode","toggleExpand","_ref7","isExpand","newExpandItemValues","Set","add","delete","getTreeNodeTitle","label","isValidElement","_nodes","join","getChildrenByFlattenNodes","_item$parent","uncheckable","useTreeDrag","_useState","dragOverNodeKey","setDragOverNodeKey","_useState2","setDragNodeKeys","_useState3","setDropNodePosition","setDragNode","current","useFlattenTreeData","_ref8","labelKey","_ref8$uncheckableItem","uncheckableItemValues","_useState4","create","dispatch","forceUpdate","flattenTreeData","treeData","layer","_extends2","getNodeFormattedRefKey","serializeListOnlyParent","key","list","keys","currentNode","parentNode","checkAll","unSerializeList","_ref9","_ref9$value","cascade","uncheckableValue","formatVirtualizedTreeData","options","formatted","curNode","checkState","hasChildren","useTreeNodeRefs","saveTreeNodeRef","ref","useTreeSearch","searchBy","filterVisibleData","setVisible","_useState5","searchKeywordState","setSearchKeyword","_useState6","setFilteredData","handleSearch","handleSetFilteredData","useGetTreeNodeChildren","_useState7","loadingNodeValues","setLoadingNodeValues","_useState8","setData","concatChildren","treeNode","newData","loadChildren","prev","Promise","then","res","focusToActiveTreeNode","_ref10","_activeItem$focus","virtualized","container","formattedNodes","_list$scrollToRow","scrollIndex","scrollToRow","activeItem","getTreeNodeIndent","rtl","absolute","_ref12","offset","_ref11","createDragPreview","className","dragPreview","document","createElement","id","innerHTML","classList","body","appendChild","removeDragPreview","_dragPreview$parentNo","_dragPreview$parentNo2","getElementById","removeChild","stringifyTreeNodeLabel","_nodes2","getParentMap","WeakMap","_item5","_iterator2","_step2","set","getKeyParentMap","getKey","Map","_item6","_iterator3","_step3","getPathTowardsItem","target","getParent","path","unshift"],"sources":["/home/strafegod/codes/tkpris/web/node_modules/rsuite/esm/utils/treeUtils.js"],"sourcesContent":["'use client';\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../internals/Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants';\nimport { attachParent } from './attachParent';\n// gap of tree node\nvar TREE_NODE_GAP = 4;\n\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n *\n * @deprecated This {@link UNSAFE_flattenTree} function is considered unsafe because it mutates `tree` argument in-place\n *             Use {@link flattenTree} instead.\n */\nexport function UNSAFE_flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n  var flattenData = [];\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      flattenData.push(attachParent(node, parent));\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n  traverse(tree, null);\n  return flattenData;\n}\nexport var WalkTreeStrategy;\n(function (WalkTreeStrategy) {\n  WalkTreeStrategy[WalkTreeStrategy[\"DFS\"] = 0] = \"DFS\";\n  WalkTreeStrategy[WalkTreeStrategy[\"BFS\"] = 1] = \"BFS\";\n})(WalkTreeStrategy || (WalkTreeStrategy = {}));\nexport function flattenTree(rootNodes, getChildren, walkStrategy) {\n  if (walkStrategy === void 0) {\n    walkStrategy = WalkTreeStrategy.BFS;\n  }\n  var result = [];\n  if (walkStrategy === WalkTreeStrategy.BFS) {\n    walkTreeBfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  } else if (walkStrategy === WalkTreeStrategy.DFS) {\n    walkTreeDfs(rootNodes, getChildren, function (node) {\n      return result.push(node);\n    });\n  }\n  return result;\n}\nexport function walkTreeBfs(rootNodes, getChildren, callback) {\n  for (var queue = [].concat(rootNodes); queue.length > 0;) {\n    var _node = queue.shift();\n    callback(_node);\n    var children = getChildren(_node);\n    if (children) {\n      queue.push.apply(queue, children);\n    }\n  }\n}\nexport function walkTreeDfs(rootNodes, getChildren, callback) {\n  for (var _iterator = _createForOfIteratorHelperLoose(rootNodes), _step; !(_step = _iterator()).done;) {\n    var _node2 = _step.value;\n    callback(_node2);\n    var children = getChildren(_node2);\n    if (children) {\n      walkTreeDfs(children, getChildren, callback);\n    }\n  }\n}\n\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n  var parents = [];\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n  traverse(node);\n  return parents;\n}\n\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n  var traverse = function traverse(node) {\n    var _node$parent;\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n\n/**\n * shallow equal array\n * @param a\n * @param b\n */\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n    defaultExpandAll = props.defaultExpandAll,\n    childrenKey = props.childrenKey,\n    _props$defaultExpandI = props.defaultExpandItemValues,\n    defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n  if (defaultExpandAll) {\n    return UNSAFE_flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n  return defaultExpandItemValues;\n}\n\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n    defaultExpandItemValues = props.defaultExpandItemValues;\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n  return [];\n}\n\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n    top = _treeNodeElement$getB.top,\n    bottom = _treeNodeElement$getB.bottom;\n  var gap = TREE_NODE_GAP;\n\n  // bottom of node\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  }\n\n  // top of node\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n    childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1);\n        // when children is empty, delete children prop for hidden anchor\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n        break;\n      }\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n    childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n      dropNode = params.dropNode,\n      dropNodePosition = params.dropNodePosition;\n    var cloneDragNode = _extends({}, dragNode);\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n            _item2[childrenKey].push(cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n      if (_isArray(_item3.children)) {\n        var _node3 = findNode(_item3.children);\n        if (_node3) {\n          return _node3;\n        }\n      }\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n    return undefined;\n  };\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n    var nextNodes = [];\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n    return nextNodes;\n  };\n  return findNodes(data);\n}\n\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n    valueKey = props.valueKey,\n    childrenKey = props.childrenKey,\n    expandItemValues = props.expandItemValues;\n  var items = [];\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n      if (!disabled && node.visible) {\n        items.push(node);\n      }\n      // always expand when searching\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n  loop(filteredData);\n  return items;\n};\n\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n  return null;\n};\n\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n/**\n * focus next item with keyboard\n * @param param\n */\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n    focusableItems = _ref3.focusableItems,\n    treeNodesRefs = _ref3.treeNodesRefs,\n    selector = _ref3.selector,\n    valueKey = _ref3.valueKey,\n    callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n  if (focusableItems.length === 0) {\n    return;\n  }\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n\n/**\n * focus prev item with keyboard\n * @param param\n */\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n    focusableItems = _ref4.focusableItems,\n    treeNodesRefs = _ref4.treeNodesRefs,\n    selector = _ref4.selector,\n    valueKey = _ref4.valueKey,\n    callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n  if (focusableItems.length === 0) {\n    return;\n  }\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n    expand = _ref5.expand,\n    onExpand = _ref5.onExpand,\n    onFocusItem = _ref5.onFocusItem;\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n    expand = _ref6.expand,\n    childrenKey = _ref6.childrenKey,\n    onExpand = _ref6.onExpand,\n    onFocusItem = _ref6.onFocusItem;\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\nexport { getTreeActiveNode };\n\n/**\n * toggle tree node\n * @param param0\n */\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n    isExpand = _ref7.isExpand,\n    expandItemValues = _ref7.expandItemValues,\n    valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n    return _nodes.join('');\n  }\n}\n\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n  var _useState = useState(null),\n    dragOverNodeKey = _useState[0],\n    setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n  var _useState2 = useState([]),\n    dragNodeKeys = _useState2[0],\n    setDragNodeKeys = _useState2[1];\n  var _useState3 = useState(null),\n    dropNodePosition = _useState3[0],\n    setDropNodePosition = _useState3[1];\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n/**\n * hooks for flatten tree structure\n * @param param0\n */\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n    labelKey = _ref8.labelKey,\n    valueKey = _ref8.valueKey,\n    childrenKey = _ref8.childrenKey,\n    _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n    uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n    callback = _ref8.callback;\n  var _useState4 = useState(Object.create(null)),\n    dispatch = _useState4[1];\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n    treeData.map(function (node) {\n      var _extends2;\n      var value = node[valueKey];\n      /**\n       * because the value of the node's type is string or number,\n       * so it can used as the key of the object directly\n       * to avoid number value is converted to string. 1 and '1' will be convert to '1'\n       *  we used `String_` or `Number_` prefix\n       */\n      var refKey = getNodeFormattedRefKey(value);\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n      flattenTreeData(node[childrenKey], node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n      key = _ref9.key,\n      _ref9$value = _ref9.value,\n      value = _ref9$value === void 0 ? [] : _ref9$value,\n      cascade = _ref9.cascade,\n      uncheckableItemValues = _ref9.uncheckableItemValues;\n    // Reset values to false\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n      searchKeyword = options.searchKeyword;\n    return UNSAFE_flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n      return formatted;\n    });\n  };\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data);\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n\n/**\n * A hook that saving every tree node ref\n */\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n/**\n * A hook that handles tree search filter options\n * @param props\n */\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n    childrenKey = props.childrenKey,\n    searchKeyword = props.searchKeyword,\n    data = props.data,\n    searchBy = props.searchBy,\n    callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]);\n\n  // Use search keywords to filter options.\n  var _useState5 = useState(searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : ''),\n    searchKeywordState = _useState5[0],\n    setSearchKeyword = _useState5[1];\n  var _useState6 = useState(function () {\n      return filterVisibleData(data, searchKeywordState);\n    }),\n    filteredData = _useState6[0],\n    setFilteredData = _useState6[1];\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    event && (callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event));\n  };\n  useEffect(function () {\n    handleSearch(searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchKeyword]);\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n    loadingNodeValues = _useState7[0],\n    setLoadingNodeValues = _useState7[1];\n  var _useState8 = useState(treeData),\n    data = _useState8[0],\n    setData = _useState8[1];\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n/**\n * Focus to active tree node.\n * @param param0\n */\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n  var list = _ref10.list,\n    valueKey = _ref10.valueKey,\n    activeNode = _ref10.activeNode,\n    virtualized = _ref10.virtualized,\n    container = _ref10.container,\n    selector = _ref10.selector,\n    formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n  var activeItem = container.querySelector(selector);\n  if (!activeItem) {\n    return;\n  }\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n  if (absolute === void 0) {\n    absolute = false;\n  }\n  // layer start from 1\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n  if (absolute) {\n    var _ref11;\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}\n\n/**\n * according to the value type to get the formatted valueKey of the node\n * @param value\n * @returns\n */\nexport function getNodeFormattedRefKey(value) {\n  return \"\" + (typeof value === 'number' ? 'Number_' : 'String_') + value;\n}\n\n/**\n * create drag preview when tree node start drag\n * @param name\n * @param className\n * @returns\n */\nexport function createDragPreview(name, className) {\n  var dragPreview = document.createElement('div');\n  dragPreview.id = 'rs-tree-drag-preview';\n  dragPreview.innerHTML = name;\n  dragPreview.classList.add(className);\n  document.body.appendChild(dragPreview);\n  return dragPreview;\n}\n\n/**\n * remove drag preview when tree node drop\n */\nexport function removeDragPreview() {\n  var _dragPreview$parentNo, _dragPreview$parentNo2;\n  var dragPreview = document.getElementById('rs-tree-drag-preview');\n  dragPreview === null || dragPreview === void 0 ? void 0 : (_dragPreview$parentNo = dragPreview.parentNode) === null || _dragPreview$parentNo === void 0 ? void 0 : (_dragPreview$parentNo2 = _dragPreview$parentNo.removeChild) === null || _dragPreview$parentNo2 === void 0 ? void 0 : _dragPreview$parentNo2.call(_dragPreview$parentNo, dragPreview);\n}\nexport function stringifyTreeNodeLabel(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes2 = reactToString(label);\n    return _nodes2.join('');\n  }\n  return '';\n}\n\n/**\n * Returns a WeakMap that maps each item in `items` to its parent\n * indicated by `getChildren` function\n */\nexport function getParentMap(items, getChildren) {\n  var map = new WeakMap();\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item5 = queue.shift();\n    var children = getChildren(_item5);\n    if (children) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {\n        var child = _step2.value;\n        map.set(child, _item5);\n        queue.push(child);\n      }\n    }\n  }\n  return map;\n}\n\n/**\n * Returns a Map that maps each item's \"key\", indicated by `getKey` function,\n * to its parent indicated by `getChildren` function\n *\n * NOTICE:\n * Using this function is discouraged.\n * Use {@link getParentMap} whenever possible.\n */\nexport function getKeyParentMap(items, getKey, getChildren) {\n  var map = new Map();\n  for (var queue = [].concat(items); queue.length > 0;) {\n    var _item6 = queue.shift();\n    var children = getChildren(_item6);\n    if (children) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(children), _step3; !(_step3 = _iterator3()).done;) {\n        var child = _step3.value;\n        map.set(getKey(child), _item6);\n        queue.push(child);\n      }\n    }\n  }\n  return map;\n}\n\n/**\n * Returns an array indicating the hierarchy path from root towards `target` item\n */\nexport function getPathTowardsItem(target, getParent) {\n  if (!target) return [];\n  var path = [target];\n  for (var parent = getParent(target); !!parent; parent = getParent(parent)) {\n    path.unshift(parent);\n  }\n  return path;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}